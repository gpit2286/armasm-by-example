[{"id":0,"href":"/docs/branches-and-conditionals/conditionals/","title":"Conditionals","section":"Branches and Conditionals","content":"Conditionals #  There was a brief mention about the status codes stored in the CPSR. This is when you get to start using them. Because assembly doesn\u0026rsquo;t have the concept of data types, the processor needs to figure out another way to define conditions such as equal, not equal, greater than, less than or equal, etc. It does this by looking at the flags of the CPSR.\nComparison methods #  The first thing you need to do is to tell the processor that you want it to update the CPSR. The first opcode you will use is cmp. cmp takes the two operands and subtracts the second from the first. From this result, it will then update the CPSR.\nmov r0, #5 @ Move 5 into r0  mov r1, #2 @ Move 2 into r1  cmp r0, r1 @ Compare r0, r1 and set CPSR From this, we now know that the processor will subtract 2 from 5, and use the result (3) to set the correct flags.\n The N flag will not be set because the number (3) is not a signed negative. The Z flag will not be set because the number (3) is not zero The C flag will be set because we didn\u0026rsquo;t not need to do an imaginary borrow to solve The V flag will not be set because there was no overflow (greater than or equal to 231, or less than â€“231)  The -S suffix #  The other common way to set the CPSR flags is by appending an -s suffix to an opcode. Not all opcodes can take the -s suffix, but most can. It\u0026rsquo;s always worth checking the processor guides when in doubt. The CPSR will be set based on the result of the operation. 1\nmov r0, #2 @ move 2 into r0  mov r1, #1 @ move 3 into r1  adds r0, r1 @ adds 2 and 3 stores into r0  @ ALSO sets the following flags based on the number 5  @ N = 0 because 5 is not signed negative  @ Z = 0 because 5 is not zero  @ C = 0 because there was no carry  @ V = 0 because there was no overflow Conditional table #  From there you can see how the processor interprets the results with this table. Using the table, you can see that because of the flags set above, the following conditions are true for 5 - 2:\n The two numbers are not equal (Z == 0) The first number is signed greater than (Z==0) \u0026amp;\u0026amp; (N==V) The first number is signed greater than or equal (N==V) The first number is unsigned higher or same (C==1) The result is positive (N==0) There was no signed overflow (V==0) The first number is unsigned higher (C==1) \u0026amp;\u0026amp; (Z==0)     Condition Code Meaning with cmp Status of Flags     EQ Equal Z==1   NE Not Equal Z==0   GT Signed Greater Than (Z==0) \u0026amp;\u0026amp; (N==V)   LT Signed Less Than N!=V   GE Signed Greater Than or Equal N==V   LE Signed Less Than or Equal (Z==1)   CS or HS Unsigned Higher or Same (or Carry Set) C==1   CC or LO Unsigned Lower (or Carry Clear) C==0   MI Negative (or Minus) N==1   PL Positive (or Plus) N==0   AL Always executed N/A   VS Signed Overflow V==1   VC No signed Overflow V==0   HI Unsigned Higher (C==1) \u0026amp;\u0026amp; (Z==0)   LS Unsigned Lower or same (C==0)    Conditions in practice #  From here, you can use these condition codes and affix them to most opcodes!\nmov r0, #5 @ Move 5 into r0  mov r1, #7 @ Move 7 into r1  cmp r0, r1 @ Internally performs 5-7 and updates CPSR  @ based on result (-2),  @ specifically Z = 0 in this case  addeq r0, #10 @ Will NOT add 10 (eq requires Z == 1)  addne r0, #5 @ Will add 5 (ne requires Z == 0)   Since CMP uses subtraction it is essentially using the SUBS opcode. The difference is that SUBS will save the result, CMP discards it.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":1,"href":"/docs/arithmetic/errors-and-tests/","title":"Errors and Tests","section":"Arithmetic","content":"Errors and Tests #  Both of these topics are important and not explicitly covered in this tutorial. However, the sooner you start thinking about them, the better off you will be when you need/want to include them in your program. They are not presented here to give answers, only to make sure you are considering them.  Error handling #  One of the two things that you miss in this series of exercises is error handling. The Linux kernel allows you to specify exit codes when we exit a program. In the regard, it is easy for you to keep a table of possible errors and encode those exit numbers inside of your program. After that, you start entering the rabbit hole of what other information do you want to give?\nPretend you wrote a program that takes two arguments at runtime. The first argument should be a number and the second argument should be a string. If that first argument isn\u0026rsquo;t a number you could:\n do nothing and the program panics (crashes) just exit the program with a specific error code exit the program with an error code, but call an error routine that will print out a message saying what the error was  Assume that the number is a number. Is it in range? Can your program handle the number if it\u0026rsquo;s zero? There are all kinds of problems that can arise, and they need to be planned for eventually. These considerations become even more prevalent if you\u0026rsquo;re writing a program for an embedded system. Do you blink an LED? Make a buzzer sound? How do you differentiate that LED blink or buzzer sound from one error to another?\nEvery programming language has generally come up with some system of error handling. But when the language itself doesn\u0026rsquo;t, you need to be very mindful as well as deciding how to mitigate those errors when they do occur.\nTesting assembly #  The other part that is not addresses in this set of exercises but should be mentioned is testing your code. As your program gets bigger and bigger and includes more and more subroutines, testing becomes more important.\nThe main premise of a testing suite is that you have a test runner that runs a series of mini-programs that assert that shared functions come back with expected results. There is also end-to-end testing that makes sure that the whole program works together in \u0026ldquo;real world\u0026rdquo; situations.\nAs you might have guessed, there isn\u0026rsquo;t really a \u0026ldquo;test suite\u0026rdquo; that is made to work with assembly out of the box. There are generic test runners, such as BATS, where you can create a separate test program, build them automatically with a make file, and then test them.\nTesting setup example #   You create a function that adds 2 to a number and returns the result You import that function into a file that only has test cases If the test result doesn\u0026rsquo;t match the expected result, send error code xxx where xxx is defined in the test file Run the test file in a test runner. If it exits with no error, then all the tests passes. If there was an error, use the test file, the returned error code, and a debugging program like GDB to find what went wrong and fix it  "},{"id":2,"href":"/docs/fpu/overview/","title":"FPU Overview","section":"Appendix A: VFP Coprocessor","content":"FPU Overview #  In addition to the core processor, there can exist an optional co-processor that works with floating point numbers. Since the release, this co-processor has become almost synonymous to the NEON co-processor which you will learn about in the next appendix.\nMnemonics #  Many of the instructions you used with the core processor exist in the FPU, but they are prefixed with a \u0026lsquo;V\u0026rsquo;. A full list is here. You\u0026rsquo;ll also notice that many of them require you to specify if you want to use 32-bit (single) or 64-bit (double) precision. You also get to use a new square root instruction!\nRegisters #  There are 32 32-bit registers that can also be addresses as 16 64-bit registers. The 32 32-bit registers are labeled as s0, s1, s2, etc for Single precision.\nLikewise the double registers are labeled d0, d1, d2, etc. for Double precision. Because of this, s0 and s1 combined are the same as d0 and likewise throughout the registers. (e.g., s2 and s3 are the same as d1, s4 and s5 are the same as d2)\nData section #  With these new data types, you need new directives to load numbers into memory. This is done with the following:\n.data numone:.single 1.223, 1.223 @ single precision floating numbers numtwo:.double 1.223, 1.223 @ double precision \u0026#34;\u0026#34; \u0026#34;\u0026#34; Compiling #  Compiling the programs you write with floating point support requires one change. When using the FPU you need to tell the compiler which version of the FPU you want to use. For all Raspberry Pi\u0026rsquo;s, this will work:\nas -mfpu=vfp -o main.o main.s Quirks #  Rounding errors #  You may already know about this problem. When you take a number and display it in a floating point fashion, you are bound to get rounding errors. This is because the computer doesn\u0026rsquo;t store numbers in a decimal fashion, it uses binary. This can be mainly avoided by using a fixed point decimal \u0026ndash; but that is not what you have here. You want an example? Go find your favorite language that uses floating point numbers, and have it evaluate 0.2 + 0.1 Your answer more than likely will be 0.30000000000000004. You will learn more about this in the exercise.\nNaN #  The concept of not a number doesn\u0026rsquo;t really exist core processor. Because everything can be interpreted in the series of bits, everything can be a number. However, in floating point numbers, you can have a set of bits that doesn\u0026rsquo;t make a floating point number. For instance, taking the square root of a negative number produces a number + i. The way you can detect that the processor didn\u0026rsquo;t complete an operation successfully is that the exponent number will be all 1\u0026rsquo;s.\n"},{"id":3,"href":"/docs/neon/overview/","title":"NEON Overview","section":"Appendix B: NEON Coprocessor","content":"NEON Overview #  With all of the cool things computers can do these days, this may be one of the most exciting things. Many times in computing you need to do the same operation to a set of data. This could include color correcting pixels on a screen, running a cryptography algorithm, and determining reflection/blur results. For the longest time, processors were limited to calculating these with one instruction that resulted in one data point. (i.e., single instruction, single data or SISD) But NOW there are processors that can perform one instruction to transform multiple data points. (i.e., single instruction, multiple data or SIMD) The NEON co-processor in the ARM chips is their SIMD implementation.\nThere is going to be a lot of information written below with very little examples. It is all important as NEON adds a lot of possibilities. For any question you have, here is a link to the docs for the NEON co-processor Also, worth noting, generally compilers and assemblers and analyzers are not great at detecting opportunities to implement this automatically and need at least some hints from the programmer. There are some libraries in different languages that can help, but again outside the scope of these lessons.\nRegisters #  If your chip has the NEON co-processor, it either also has the VFP or has the VFP integrated into the NEON co-processor. For this reason, NEON uses the same registers that the VFP uses, but can also look at them from a larger view.\nNEON cannot address the S registers directly, but it can address the D registers directly. In addition, it can look at the registers from a Quad (128-bit) viewpoint that combines two D registers.\nNot Addressable | D regs | Q Regs | S0 D0 Q0 S1 S2 D1 S3 S4 D2 Q1 S5 S6 D3 S7 S8 D4 Q2 ... (Ends S31) D31 Q15 D32 Lanes #  NEON cannot do 128-bit math. The reason why it has space this large is because you can put data into \u0026ldquo;lanes\u0026rdquo; in order to do the parallel processing. A 128-bit register can have:\n 16 8-bit lanes 8 16-bit lanes 4 32-bit lanes 2 64-bit lanes  You can also use the D registers to provide 64-bit space total which will provide half of the above lanes for each dat size.\nMnemonics #  Many of the same V operations can be used but the syntax is slightly different. The syntax is:\nV{\u0026lt;mod\u0026gt;}\u0026lt;instruction\u0026gt;{\u0026lt;shape\u0026gt;}{\u0026lt;cond\u0026gt;}{.\u0026lt;dt\u0026gt;} \u0026lt;dest1\u0026gt;{, \u0026lt;dest2\u0026gt;}, \u0026lt;src1\u0026gt;{, \u0026lt;src2\u0026gt;} \u0026lt;mod\u0026gt; #  This modifies the instruction on how to handle things like overflow and underflow. It can be one of the following or omitted:\n Q (saturation): Each element in the result vector is set to either the maximum or minimum if it exceeds the representable range. H (halved): Each element shifted right by one place (effectively a divide by two with truncation). D (double): The opposite of halved. The doubling happens before any saturation would take place. R (rounded): The instruction rounds the result to correct for the bias caused by truncation. This is equivalent to adding 0.5 to the result before truncating.  \u0026lt;shape\u0026gt; #  When an operation is performed, there are always as many outputs as there are inputs. Sometimes the size of the data after an operation creates is different. (e.g., think about how it takes 32-bit to store two 16-bit numbers multiplied together) These are for those instances, but can be omitted if they don\u0026rsquo;t apply.\n L (long): Operands are the same width. Number of bits in each result element is double the number of bits in each operand element. N (narrow): Operands are the same width. Number of bits in each result element is half the number of bits in each operand element. W (wide): Result and operand are twice the width of the second operand.  \u0026lt;cond\u0026gt; #  This refers to the conditional execution depending on CPSR settings.\n.\u0026lt;dt\u0026gt; #  This is the data type. This is similar to the way that the FPU used the .f32 and .f64 but refers to the lane size. They include:\n U8, U16, U32, U64: unsigned integers S8, S16, S32, S64: signed integers I8, I16, I32, I64: unspecified integer F161, F32: floating point P8, P16: Polynomial over {0,1}  Scalar data #  Scalar refers to a single value instead of a vector containing multiple values. Some NEON instructions use a scalar operand. A scalar inside a register is accessed by index into the vector of values.\nvmov.i8 d0[3], r3 @ move r3 into the 4th byte of d0  @ this is because it is zero indexed. Compiling #  As with the FPV, you will need to tell the assembler that you are expecting a processor that has extended features. Below should work for most processors with fpu and NEON support. If it doesn\u0026rsquo;t, you will need to find the exact match. The docs linked at the beginning of this lesson will help.\nas -mfpu=neon-vfpv4 -o main.o main.s   Not all NEON co-processors support F16.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":4,"href":"/docs/working-in-linux/add-the-arguments/","title":"Program 17: Add the Arguments","section":"Working in Linux","content":"Reading program arguments #  The first type of interaction you will learn about is how arguments are passed to a program from the Linux command line. To understand/visualize this, I HIGHLY recommend installing an extension such as GEF for the GNU debugger.\nTake one of the programs you have created and start it in GDB. When you do this, set a break point at _start and run it using the command: r arg1 arg2 arg3. This will start the program running, pause on the first line and pass three arguments to the program.\nIf you\u0026rsquo;re using an extension, you should easily see the stack.\nThe first address (0x7efffc60) has the value of 0x4. This is the number of arguments passed into the program from the command line. You will also notice the $sp label, which refers to which address the stack pointer is pointing to.\nThe first argument passed in is always the path of the program running. In this example, the value stored at address 0x7efffc64 is the starting address of the null terminated ASCII string. Also note that the argument list is null terminated. (Address 0x7efffc74) Every other argument is the same. The value stored on the stack is the address of where the value is in memory. It is important to also remember that all of these will be passed in as they are typed. (i.e., ASCII and not integers) You CAN use escape codes or pipe in information from another program, but when calling from the CLI, you\u0026rsquo;re almost always going to be working with arguments in ASCII.\n"},{"id":5,"href":"/docs/registers-and-memory/register-overview/","title":"Register Overview","section":"Registers and Memory","content":"Register overview #  As mentioned before, the registers are inside the processor and allow the processor to operate on data. The ARM processor can not do calculations or manipulate data directly inside the memory. The ARM processor has 16 32-bit registers (r0-r15).\nSane register usage #  While technically you can use every register, some of the registers are reserved for\nspecific functions.\n r0 - r12: General purpose - Use without care of reserved functionality r13: Stack pointer - Address location of stack in memory r14: Link register - Address location of where to return to after branch r15: Program counter - Address location of \u0026ldquo;next\u0026rdquo; operation to perform  And then, within the general purpose registers, there are some soft rules.\n r0-r3 is generally reserved for calling functions r4-r12 is generally safe to preserve data after/during function calls  The most important take away: Don\u0026rsquo;t use r13-r15 unless you really understand what you\u0026rsquo;re doing.  The 17th register #  Ok, I lied a little. There is a 17th register called the Current Program Status Register (CPSR). The CPSR keeps track of things that the processor needs to know when executing operations. It keeps track of things like condtional states, endianness, thumb mode enabled, interrupt flags, processor mode, etc.\nFor right now, of the 32-bits in the register, you only need to worry about bits 28-31. These bits will allow you to start writing conditional operations soon.\n 31: Negative: If N is 1 the signed value is negative, and cleared if the result is positive or zero. 30: Zero: set if the result is zero 29: Carry:  With the instructions ADC, ADD, and CMN, this flag is set if the result would produce an unsigned overflow. With the instructions CMP, SBC, and SUB, this flag is set if the result would not need a borrow from an imaginary bit.1 For other instructions that use shifting, this flag is set to the value of the last bit shifted out by the shifter. Other instructions usually leave this flag alone.   28: oVerflow: for addition and subtraction, this flag is set if a signed overflow occurred. Otherwise, it is generally left alone. Note that some API conventions may specifically set oVerflow to flag an error condition.    I think of this as this is the bit that would be borrowed from for subtraction operations.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":6,"href":"/docs/bit-operations/signed-numbers/","title":"Signed Numbers","section":"Bit Operations","content":"Signed Numbers #  You may believe that I have made a mistake \u0026ndash; how could negative numbers appear under the section about \u0026ldquo;Bit Operations\u0026rdquo; and not \u0026ldquo;Arithmetic\u0026rdquo;. It is because the way that the computer understands negative numbers has everything to do with manipulating bits in a certain way and less to do with negative numbers themselves.\nIf you take the number 210 and write it out in individual bits, it would be 0b11010010. This is also the way that -46 is represented in 1-byte. The processor, for all intents and purposes, has no idea if a number is negative or positive. It just knows 0b11010010.\nSigned v. unsigned #  When you hear someone talk about \u0026ldquo;signed\u0026rdquo; and \u0026ldquo;unsigned\u0026rdquo; numbers, this is exactly what they are talking about. Do you look at the series of bytes and interpret the number as possibly being negative or a larger positive number. In 1 byte, an unsigned integer can have the value of 0-255. If that single byte represented a signed integer, the range changes from -128 to 127. The signed values 128-255 are used to represent -128 to -1.\nCalculating negative numbers \u0026ldquo;on paper\u0026rdquo; #  Some very smart people looked at computer bits and had this discussion: (probably)\n 1: Hey Fred, this computer is great. Can I put a negative number in there? 2: Well, no. There\u0026rsquo;s no negative numbers. They\u0026rsquo;re all positive. 1: That\u0026rsquo;s not helpful.  Person 1\u0026rsquo;s name is John von Neumann and he discovered that you can use the same bytes and have them act like a negative number.\nTake the number -46 from above. Positive 46 is stored as 0b00101110. The first step is to take all of the bits and flip them. This would result in the binary becoming 0b11010001. This is called one\u0026rsquo;s compliment. We then add 1 to the resulting number and get 0b11010010. This is call the two\u0026rsquo;s compliment and is the form that negative numbers take. Try adding one.\n0b11010010 -46 + 0b00000001 + 1 ================== 0b11010011 -45 We can verify this by finding the two\u0026rsquo;s compliment for 45.\n0b00101101 45 0b11010010 One\u0026#39;s compliment 0b11010011 Two\u0026#39;s compliment. Same as -45 above. And you should be able to add 46 and -46 together and get 0. (Wait. Right? RIGHT?!?!)\n0b00101110 46 + 0b11010010 +-46 ==================== 0b00000000 0 If you are astute, you may have noticed that there should have been a 1 that gets carried. You are correct. This 1 goes to the carry bit in the CPSR and is discarded from the register doing the addition.\nCalculating negative numbers \u0026ldquo;in code\u0026rdquo; #  MVN operation #  MVN is the mov not operation. This operation moves the inverse of the number you write. This makes it very easy to \u0026ldquo;flip the bits\u0026rdquo; of a number.\nYou then just need to add 1, which you already need to do.\nmvn r0, #46 @ mov the opposite of 46 into r0. since this is  @ actually a 32 bit register it now contains  @ 11111111 11111111 11111111 11010001  add r0, #1 @ add 1 to get two\u0026#39;s compliment  @ r0 now equals -46, which in the 32 bit space would  @ look like this:  @ 11111111 11111111 11111111 11010010 "},{"id":7,"href":"/docs/getting-to-hello-world/basics/","title":"The Basics","section":"Getting to Hello World","content":"The Basics #  Dependency Check #  The first thing that we need to do is check to make sure that we have all of the correct tools that we need. The below table will tell you the program name, the command to check to make sure that it is installed, and what package includes the tool if it isn\u0026rsquo;t present.\n   Program Name Check Command Required Package     GNU Assembler as --version binutils   GNU Linker ld --version binutils   GNU Debugger gdb --version gdb   Make make --version make    Syntax #  The first part of writing programs is understanding the syntax of the language. Assembly is, maybe unsurprisingly, a little less descriptive than any other language you\u0026rsquo;ve worked with before.\nMnemonics #  Since we are using a language that interacts almost directly with the processor, there are two ways to write the commands. The first way is the manually write every 32-bit command in binary or hex. You can imagine that this is not sustainable. The second way is by using mnemonics that represent those 32-bit instructions.\nThere are essentially three types of mnemonics or opcodes. (Rd = destination, Rn = source, op2 can be a register or an immediate)\n Some opcodes don\u0026rsquo;t produce a result  opcode Rn, op2   Some opcodes only deal with single registers  opcode Rd, op2   Some opcodes produce a result from a source  opcode Rd, Rn, op2    Registers #  If I asked you to name the places that data \u0026ldquo;visits\u0026rdquo; inside of a computer, you would probably mention the hard drive/SSD and the RAM (or \u0026ldquo;memory\u0026rdquo;). There are also places inside the processor itself that the data \u0026ldquo;visits.\u0026rdquo; One of those places are the registers. There are some registers that are used for general purpose and some that are used for specific reasons. For now, just know that the registers are the places inside the register where we can actually do operations on a piece of data. They are represented as r0 - r15.\nImmediate Values #  Assembly doesn\u0026rsquo;t have the idea of a constant or really even variable assignment. In many programming languages we can think of a constant as a value that isn\u0026rsquo;t allowed to change. There is no such safeguards in assembly. So how do we write the values that we want to use that are not calculated? Immediate values are the answer.\nIf we think about an operation that the processor consumes, there is a lot of data that gets thrown into those 32-bit. Because of this, immediate values are, by space alone, limited to numbers 0-255 (unsigned). They are entered with a # sign followed by a char in single quotes or a number in binary, octal, decimal, or hexadecimal. So we can always use:\n An integer from 0 - 255 A char value from ASCII by enclosing it in single quotes  As you can see, this is quite limited. So the designers of the processor added a barrel shifter into the CPU and we can then take that base range (0-255) and shift it. All of these values would be possible:\n 0x000000FF: 255, no shift 0x00FF0000: 255, left shift 16 for a value of 16,711,680 0x000FF000: 255, left shift 12 for a value of 1,044,480  These would NOT be possible:\n 0x00234500: Rotated value (0x2345) too large 0x000007F8: Rotated value (0xFF) rotated an odd number of places 0x000001FF: Base value too large  What if we really really really needed 0x00FF0001? Compilers will transparently \u0026ldquo;fix\u0026rdquo; this for you by loading this value into memory when the program is loaded and load it into the register when needed. The downfall of this is that it takes an extra operation or two. The good thing? It only really translates into 1/500,000 of a second more or less.\nFile Format #  Unlike many programming languages, the format fo the file is quite simple. There is a \u0026ldquo;main\u0026rdquo; function that is labeled as _start. Every program needs to have one and only one _start. This is, however, not an actual function but actually just a label. (If you\u0026rsquo;ve ever had GOTO nightmares, welcome back.)\nThere also needs to be two sections in the code. The first is .text. This tells the compiler where the operations live. Also, anything that is written in this section will never change when the program is running. The .text directive is usually omitted as the compiler assumes its existence. The other section is the .data section. This loads values that cannot be entered as immediate values and can reserve space for our program to use during execution.\nThe last global directive is .global. This exposes labels from the code to the compiler and linker. For now, we will just be exposing the _start label. Below is an example source code file that will run, but produce no results.\n@ At signs are the comment marker. In assembly, you\u0026#39;ll @ use these on almost every line. They are the only way @ to keep things logical.  @ The next line tells the linker that a function is available @ in a file. .global_start  @ Every program needs a _start label. This is where the program @ will start. It does not need to be at the top of the file. @ Maybe there is another function above this. Notice that a label @ is defined by text followed by a colon. _start: @ The next line is a valid command though it\u0026#39;s not going to do much @ for you. The operation code is add which will add two numbers. The @ two operands, r2 and r3, are registers. We will talk about them in @ the next section. I generally indent op-codes one tab so that @ they don\u0026#39;t look like labels.  add\tr2, r3 @ Add r2 to r3 and store in r2  @ The next line is a section marker. Even though it looks like @ the global directive, this just tells the compiler what data @ will be loaded when the program is loaded into memory. .data @ Within the data section, we will use labels to label data in the @ same way we can label operations. There are multiple data types @ but for this example, we will label a \u0026#34;Hello World\u0026#34; string @ as hello. The .ascii is a data type that will tell the compiler @ how to interpret the data. hello:.ascii\t\u0026#34;Hello World\u0026#34; "},{"id":8,"href":"/docs/branches-and-conditionals/branches-and-loops/","title":"Branches and Loops","section":"Branches and Conditionals","content":"Branches and Loops #  Now that you can write conditional code, you need to know how to move around the code in a non-linear manner. Assembly only has one such concept and that is branch. Branch is just like GOTO in languages that support it.\nmov r0, #2 @ Move 2 into register 0 loop: add r0, #1 @ Add 1 to r0  b loop @ return to loop label As you can see above, when we branch we will branch to labels. This is another time where the compiler and linker will turn the label into a relative address while it\u0026rsquo;s being compiled. (You could write an offset to branch to, but it\u0026rsquo;s a lot less practical.) This first loop would be beneficial if you were writing something that never stopped, but this isn\u0026rsquo;t practical for much of what you\u0026rsquo;ll program.\nIF statements #  The most fundamental conditional concept you may come across is the if statement. Because there is no if keyword, the code will look similar to this:\nmov r0, #10 @ Move 10 into register 0  mov r1 ,#7 @ Move 7 into register 1  cmp r0, r1 @ Compare r0 and r1  bne lblne @ If r0 != r1, branch to lblne  add r1, #3 @ else add 3 to r1  b lblexit @ Go to end of code lblne: add r0, #3 @ Add 3 to r0  @ don\u0026#39;t need to branch to lblexit here as it\u0026#39;s the  @ next command lblexit: @ Continue code.... With this you can then start making loops.\nWHILE loop #  @ While r0 \u0026lt; 5  loop: cmp r0, #5 @ Compare r0 and 5  bge exit @ If greater than or equal, exit loop  @ Do loop operations here  b loop exit: @ continue with code FOR loop #  @ For each r0 = 0 to 5  mov r0, #0 @ Mov 0 into r0 as first number loop: cmp r0, #5 @ Compare r0 to 5  bgt exit @ Leave loop if r0 \u0026gt; 5  @ Do loop operations here  add r0, #1 @ Increment counter  b loop exit: @ continue with code "},{"id":9,"href":"/docs/arithmetic/datatypes/","title":"Datatypes","section":"Arithmetic","content":"Datatypes #  The string types #  The first set of built in data types are the two that you have already learned: ascii and asciz. To review, both ascii and asciz encode ASCII characters to their integer equivalents. The asciz directive adds a null character to the end of the string.\nThe integer types #  In the data section you can also specify integers that will be loaded with the program. In addition, you can also specify the amount of space that the integer consumes. The possible types are:\n .byte: 1 byte .short: 2 bytes .word: 4 bytes .quad: 8 bytes .octa: 16 bytes  Example of assignments #  .data label1:.byte 0x44, 0x22, 0x11 @ Loads  @ addr+0: 0x44  @ addr+1: 0x22  @ addr+2: 0x11 label2:.short 0x44, 0x22, 0x11 @ Loads  @ addr+0: 0x0044  @ addr+2: 0x0022  @ addr+4: 0x0011 label3:.word 0x44, 0x22, 0x11 @ Loads  @ addr+0: 0x00000044  @ addr+4: 0x00000022  @ addr+8: 0x00000011 "},{"id":10,"href":"/docs/registers-and-memory/memory-overview/","title":"Memory Overview","section":"Registers and Memory","content":"Memory overview #  When someone says that a computer has \u0026ldquo;memory,\u0026rdquo; it could be a number of things. There are all kinds of media that fall under this category. Any peripheral outside of the processor that stores data can be considered memory. In addition to the RAM, there may be ROM (read only memory), EEPROM (electrically erasable programmable read-only memory), flash drives, disc drives, tape cassettes\u0026hellip; In this series, when we talk about memory, we will always be talking about RAM unless specified otherwise.\nWhen you access RAM, you need to provide an address for the byte you\u0026rsquo;re trying to read.1 Most of the the time, the compiler will compute these relative addresses for you when we use labels to refer to data. So why do you need to worry about this? Eventually you will start debugging the programs you write, and you may be surprised to see that everything in memory looks backwards. This is because, be default, the ARM processor stores bytes in memory by little endian.\nEndianness #  There are many resources already that talk about endianness and I do not look to offer something novel in this aspect. However, providing a quick explanation is prudent if this is a new concept.\nWhen computers address memory, they can do so in two ways. They can either increment the address or decrement the address for \u0026ldquo;the next byte\u0026rdquo; of data. However, within a byte, the bits will always be in the same direction with the most significant bit, or the bit with the highest value, on the far left. If we\u0026rsquo;re storing the value 0x0A0B0C0D, it would be stored like this.2\n   Registers v. Memory #  The main points you need to remember about registers and memory are:\n Memory is outside of the processor, registers are inside the processor Registers are needed to operate on data as processors cannot directly operate on data inside memory of any sort. Registers are addressed by r and a number, memory is addresses by numbers that look like 0x600f.    If you want to really understand how and why this works, I HIGHLY suggest watching the Ben Eater Videos on building a computer from scratch.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Graciously stolen from Wikipedia.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":11,"href":"/docs/bit-operations/positivty/","title":"Program 11: All Positivity","section":"Bit Operations","content":"Revisiting the N flag #  You learned briefly that the N flag is set if the number, interpreted as signed,\nused to set the CPSR is a negative number. You may be surprised to know, that really this flag is a mirror of the most significant bit. No, seriously. It\u0026rsquo;s that simple. Imagine the ARM processor had 8-bit registers as opposed to 32-bit.\n   Number 8-bit register N set?     22 0b00010110 N   -22 0b11101010 Y   200 0b11101010 Y    The number 200 again illustrates that the processor itself inherently does not know if it is working with positive or negative numbers, and it\u0026rsquo;s a construct the user determines.\nLDRSB/STRSB/LDRSH/STRSH operations #  Unfortunately(?), the processor DOES have 32-bit registers. This means that if you are working with numbers that are less than 32-bits, you need to be aware or you could make some negative numbers positive very quickly.\nImagine you have these two numbers stored in single bytes: 6, -7\nIf you used the STRB operation to move 6 from memory to a register, there won\u0026rsquo;t be a problem.\nmemory: 00000000 6 ldrb: result: 00000000 00000000 00000000 00000110 6 But if you tried doing this with -7, you all of a sudden get a positive number.\nmemory: 11111001 -7 ldrb result: 00000000 00000000 00000000 11111001 249 To accommodate for this, the architects implemented signed load and store instructions for byte and half word operations. 1 Essentially it just takes the bit in the most significant position of the loaded data and fills that to the rest of the data space.\nmemory: 11111001 -7 lrdsb result: 11111111 11111111 11111111 11111001 -7   No need to do this for word operations because the load/str will never add empty bytes to the register.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":12,"href":"/docs/working-in-linux/add-the-inputs/","title":"Program 18: Add the Inputs","section":"Working in Linux","content":"Reading input and the docs #  As you dig in deeper and deeper into your programming journey, it becomes more and more important to be able to read the docs. As boring and monotonous as that sounds, this is the best way to learn. Start by looking at the table of syscalls that you saw before. You can see that read is #3.\nTo learn more about the read operation, you can use the man pages by looking at the 2 (syscall) entry. In the terminal type: man 2 read This tells you everything you need to know about how to make this syscall and what variables it is expecting.\nAs you read this man page, you can see that read takes three arguments. For this exercise, you will read from stdin. To give them to the supervisor, you will put them in r0, r1, and r2 \u0026ndash; very much in the same way you call write!\n int fd: 0 = stdin void *buf: The * tells you that is is expecting an address. So this is where the output buffer space is in memory. Since the largest unsigned 32-bit number is 4,294,967,296, this needs to be 10. You can make this a null terminated area for easier processing. (Just change the number of bytes to 11 as opposed to 10) size_t count: This is the max number of characters you are willing to read. Again, since the largest number is 10 digits, you only want to accept 10 digits.  Automatic length calculation #  Imagine you have a long string in the data section and you don\u0026rsquo;t want to calculate the length. Or possible a string where the length may change. You can use the following form to automatically calculate the length on compile. The dot acts as representation of \u0026ldquo;this memory address here\u0026rdquo; and then you subtract the address at the given label. This results in the length:\n.data prompt:.asciz \u0026#34;Input a number to add or Enter to sum:\\n\u0026#34; promptlen:.word .-prompt Another quick note about errors #  Again, I feel like I need to stress the absence of error checking in these examples. Especially when it comes to reading user input: things will go wrong. If the numbers added overflow, there is no check there. If the number entered is negative, there is no check there. If the input length is \u0026gt; 10, there isn\u0026rsquo;t really a check there. Please, please, please, stand on the shoulders of those who came before you and always be aware of all the ways something can go wrong. This is more true in assembly than any other programming language.\n"},{"id":13,"href":"/docs/getting-to-hello-world/exiting/","title":"Program 1: Exiting","section":"Getting to Hello World","content":"While you may wonder why you need to talk about how to exit a program, know that you do. Unlike many higher languages, assembly programs don\u0026rsquo;t gracefully exit when you stop writing code. What happens if you don\u0026rsquo;t exit the program is the the computer will keep reading data in memory past the last opcode. Because you are running in a *nix environment, you will get a segmentation fault as it will drift into memory you don\u0026rsquo;t have access to. If this were an embedded solution (with no operating system), it is the definition of unexpected behavior.\nMOV operation #  The first operation you are going to use is mov. mov moves a value into a register. It can move an immediate value or a value stored in another register.\nmov r0, #2 @ moves the value 2 into register 0  mov r1, r0 @ copies the value 2 from register 0 to register 1  @ register 0 is still equal to 2 Supervisor Calls #  Supervisor calls or system calls (syscalls) are the way that our program communicates with the operating system (known as the supervisor). There is a whole list of calls that you can make ranging from opening files, to forking processes, to exiting programs.\nThere are two ways you can make supervisor calls in ARM assembly, but we will only be using this format:\n Supervisor call number loaded into r7 (without the 0x900000 prefix) Parameters generally loaded into r0-r3 Supervisor call executed with the command svc 0  Reading the syscall table #  Take a second and go to the link labeled as whole list. You can see the name is the name of the function. For this first example, you need exit. As you can see it\u0026rsquo;s close to the top. If you read across the table, you can see the next column is labeled as r7. This is the number you need to put into register 7, but without the 0x900000 prefix. (i.e., 1) The next couple of columns are the parameters that will be passed to the function, conveniently labeled r0-r5. For the exit call, you only need one parameter put into r0, which is the int error_code.\nA Note about data types #  The exit call expects an integer. You will see that when you use this, you can\u0026rsquo;t tell the computer that you are using and integer, but only put a number into the register. The types that are listed in this table, for the assembly programs you will be writing, should be approached as \u0026ldquo;this the the type the kernel will interpret the value as.\u0026rdquo; While it may not effect us too much in this course, consider this.\nImagine you are calling the read command and the file descriptor is 4,294,967,259. (Not practical but suspend disbelief.) Because the read call expects an unsigned integer, this would be fine. Now imagine that there was some crazy error and you wanted to pass the file descriptor as the error code on the exit call to debug. Since the exit call is NOT unsigned, it would actually output -37 because the exit call can be negative. We\u0026rsquo;ll talk more about this later, but just keep this in the back of your head when you are reading the table and interpreting the data types.\nCompiling and Running #  To compile the program, you actually need to run two commands. If the filename is main.s, the first command you need to run is:\nas -o main.o main.s This will invoke the assembler and take all of the code we wrote and convert it into the 1\u0026rsquo;s and 0\u0026rsquo;s that the processor will understand. The next thing you need to do it run the linker with:\nld -o main main.o This will take the raw code and organize it in the way the operating system and processor expects it to be in. You can then finally run:\n./main and get the result.\n"},{"id":14,"href":"/docs/fpu/here-to-there/","title":"Program 20: Here to There","section":"Appendix A: VFP Coprocessor","content":"Floating point numbers #  How does a floating point number actually work? IEEE 754 is the tech sheet that talks about floating point numbers. For single precision, it says that the layout is:\n   Sign (+/-) Exponent Fraction     bit 31 bits 23-30 bit 0-22    For double precision it is:\n   Sign (+/-) Exponent Fraction     bit 63 bits 52-62 bit 0-51    The sign bit is the easy part. If the bit is 1, it is negative and if it\u0026rsquo;s 0 the number is positive.\nThe next set of bits are the exponent for the number 2. When representing the exponent, the number here will never be read as negative. Instead, the exponent is read as a positive and a bias is removed. (127 for single and 1023 for double) So if, in a single precision float, the exponent is written as 129, the exponent is really 2. (129-127)\nThe fraction or mantissa is represented as 1 (not encoded) plus the addition of 2^-x where x is the 1-indexed bit from the most significant side. If the fraction started with 101011\u0026hellip; it would represent.\n  \\[1 \u0026#43; 2^{-1} \u0026#43; 2^{-3} \u0026#43; 2^{-5} \u0026#43; 2^{-6} ... \\\\ \\text{or} \\\\ 1 \u0026#43; \\frac{1}{2} \u0026#43; \\frac{1}{8} \u0026#43; \\frac{1}{32} \u0026#43; \\frac{1}{64} ... \\]  If you really want to dig into this conversion, this website is one of the most clear and concise explanations I\u0026rsquo;ve found.\n"},{"id":15,"href":"/docs/neon/bus-rider/","title":"Program 21: Bus Rider","section":"Appendix B: NEON Coprocessor","content":"This is, without a doubt, a simple introductory program to use the NEON co-processor. It has all kinds of uses but I wanted to find something that was both simple and more concrete then \u0026ldquo;LOOK HOW COOL IT IS WHEN WE USE RANDOM NUMBERS TO DO RAY TRACING!!\u0026rdquo; A little backgrounds on matrices first if you don\u0026rsquo;t know how they can be solved.\nMatrices #  If you think back to linear algebra, you will probably remember a small part where you were working with matrices. I know when I was in math, it wasn\u0026rsquo;t presented in a way that made it practical. They look something like this (I hope this doesn\u0026rsquo;t give you bad flashbacks):\n  \\[\\begin{bmatrix} 1 \u0026amp; 2 \\\\ 3 \u0026amp; 4 \\end{bmatrix}\\]  Multiplying matrices #  If you have two matrices and want to multiply them, this is the formula. Multiply each member of the the first matrix\u0026rsquo;s row by every member of the second matrix\u0026rsquo;s corresponding column and add them. I will not go into all of the questions like \u0026ldquo;why? how? magic? wtf?\u0026rdquo; here.\n \\[\\begin{bmatrix} 1 \u0026amp; 10 \u0026amp; 100 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 2 \\\\ 3 \u0026amp; 4 \\\\ 5 \u0026amp; 6 \\\\ \\end{bmatrix} = \\begin{bmatrix} 531 \u0026amp; 642 \\end{bmatrix}\\]   \\[531 = (1\\times1) \u0026#43; (10\\times3) \u0026#43; (100\\times5) \\\\ 642 = (1\\times2) \u0026#43; (10\\times4) \u0026#43; (100\\times6)\\]  Inverse matrices #  The cool thing about matrices is that the concept of division is absent. There is only multiplication of the inverse. This is similar to how  \\(6^1 \\times 6^{-1} = \\frac{6}{1} \\times \\frac{1}{6} = 1\\)  Matrices IRL #  From the information above, you can then solve series of linear equations. Again, without getting into the details too much, look at this problem graciously borrowed from mathisfun.com.\n A group took a trip on a bus, at $3 per child and $3.20 per adult for a total of $118.40. They took the train back at $3.50 per child and $3.60 per adult for a total of $135.20. How many children, and how many adults?\n In this equation there are two constants. The number of children (x) and the number of adults (y). You could write this as two equations.\n \\[\\text{Bus Trip:} \\quad\\$3.00x \u0026#43; \\$3.20y = \\$118.40 \\\\[2pt] \\text{Train Trip:} \\quad\\$3.50x \u0026#43; \\$3.60y = \\$135.20 \\]  You may be able to see now how this would translate to a set of multiplied matrices.\n \\[\\begin{bmatrix} x \u0026amp; y \\end{bmatrix} \\begin{bmatrix} 3 \u0026amp; 3.5 \\\\ 3.2 \u0026amp; 3.6 \\end{bmatrix} = \\begin{bmatrix} 118.4 \u0026amp; 135.2 \\end{bmatrix}\\]  From here, you can multiply the result by the inverse of the known matrix and get the unknown. Getting the inverse is a little complicated and out of the scope of this simple example, but trust me that this is correct.\n \\[\\begin{bmatrix} 118.4 \u0026amp; 135.2 \\end{bmatrix} \\begin{bmatrix} -9 \u0026amp; 8.75 \\\\ 8 \u0026amp; -7.5 \\end{bmatrix} = \\begin{bmatrix} 16 \u0026amp; 22 \\end{bmatrix}\\]  So there were 16 children and 22 adults.\n"},{"id":16,"href":"/docs/bit-operations/exorcise/","title":"Exorcise and bicycle orr...","section":"Bit Operations","content":"Exorcise and bicycle orr\u0026hellip; #  Now that you have started thinking about the individual bits that make up the data that you work with on a daily basis, there are a couple of operations that allow you to do this easily.\nAND operation #  AND allows you to create a value that displays where both bits are set.\n   Val 1 Op Val 2 Result     0 AND 0 0   0 AND 1 0   1 AND 1 1   1 AND 0 0    The syntax is:\nand Rd, Rn, op2 @ Rd = destination, Rn = first value BIC operation #  The BIC performs an AND on a value and the bitwise NOT of the second value.\n    Val 1 OP Val 2 Result      0b11110000  0b01010101    NOT \u0026mdash;  0b10101010     0b11110000 AND 0b10101010 0b10100000    The syntax is:\nbic Rd, Rn, op2 @ Rd = destination, Rn = first value ORR operation #  This is a fairly easy operation that works as a logical OR. If either bit is set, then the resulting bit set will have the bit set.\n   Val 1 Op Val 2 Result     0 OR 0 0   0 OR 1 1   1 OR 1 1   1 OR 0 1    orr Rd, Rn, op2 @ Rd = destination, Rn = first value EOR operation #  I try not to write in first person much, but this is my favorite operation. The exclusive or or XOR has some cool properties. This will set a bit if only one bit of the pair is set.\n   Val 1 Op Val 2 Result     0 XOR 0 0   0 XOR 1 1   1 XOR 1 0   1 XOR 0 1    This is used in many different places in computing checksums, cryptography, random number generators, uniqueness detection\u0026hellip;\n"},{"id":17,"href":"/docs/arithmetic/multiplication/","title":"Multiplication","section":"Arithmetic","content":"Multiplication #  When a processor does multiplication, it doesn\u0026rsquo;t quite do multiplication in the way you can do it in your head. It uses a process you probably wouldn\u0026rsquo;t think about. In fact, with the ARM processors, every multiply operation takes at least ~4-6 cycles.\nMUL operation #  The MUL operation is the \u0026ldquo;basic\u0026rdquo; multiplication operation. It takes the format mul Rd, Rn, Rm where Rd is the destination and Rn and Rm are input registers.\nThis opcode, as well as all of the other multiply opcodes, only take registers as inputs: there is no possibility to use the flexible operand2.  MLA operation #  MLA stands for multiply and accumulate. As it sounds, this operation multiples two registers and then adds the value to another register. The format is mla Rd, Rm, Rs, Rn where Rd = (Rm * Rs) + Rn.\nYou may have (or many not have) realized something. If you take two 32-bit numbers, multiply them together, you will possibly get a number that takes up more than 32-bits. The above operations (MUL, MLA) will only return the 32 least significant bits. The 32 most significant bits are discarded. For that reason, there are the following operations.\nMULL and MLAL operations #  These are the \u0026ldquo;multiply long\u0026rdquo; and \u0026ldquo;multiply long and accumulate\u0026rdquo; operations. However, to complicate things a little more, they never exist in this form. They are always prefixed with a \u0026lsquo;U\u0026rsquo; and a \u0026lsquo;S\u0026rsquo; to indicate unsigned or signed multiplication.\numull r1, r2, r3, r4 @ r3 * r4, store high bits in r2, low in r1  smull r1, r2, r3, r4 @ same as above, but for signed numbers  umlal r1, r2, r3, r4 @ (r3 * r4) + (r2,r1)  @ high bits in r2, low bits in r1  smlal r1, r2, r3, r4 @ same as above, but for signed numbers SMULxy and SMLAxy operations #  Only because your head isn\u0026rsquo;t spinning enough, you can add letters to the end of the signed multiplication opcode to multiply two 16-bit integers and store them in a 32-bit register. The x and y can either be a t or a b to indicate the top or bottom half of the registers.\nsmultb r1, r2, r3 @ multiply the top 16 bits of r2 and the  @ bottom 16 bits of r3 and store in r1  smulbb r1, r2, r3 @ multiply the bottom 16 bits of r2 and the  @ bottom 16 bits of r3 and store in r1 "},{"id":18,"href":"/docs/working-in-linux/add-the-file/","title":"Program 19: Add the File","section":"Working in Linux","content":"Reading more of the docs #  For the next exercise, you will use the read call again, but on an actual file and not stdin. In the last example you knew the file descriptor was 0 for stdin. For this, you will need to first open the file in order to get the file descriptor.\nWhen you look at the man page for open (man open 2) you will the following note:\n The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. These request opening the file read-only, write-only, or read/write, respectively.\n These are actually integers \u0026ndash; the flags listed are only the variable name. So your first step should be getting the correct integers for these constants. But where do you start looking? If you look under the synopsis section of the man page, it has the files that are included. One of those files must have the definitions. After you search\nthose files ðŸ™„ you will find the information you want in the fcntl.h. If you are using a Linux based OS, it should be available at: /usr/include/asm-generic/fcntl.h Note that if you go and continue with a 64-bit version of the processor/operating system, many of the calls are different than the 32-bit version of the calls. Everything in this set of exercises works with the 32-bit calls.\nAfter all of this searching, you only need to open the file for read only which is actually equal to 0. This may be the first time of many for some of you where a long trail of bread crumbs leads to the number zero. Life\u0026rsquo;s just like that sometimes.\n"},{"id":19,"href":"/docs/getting-to-hello-world/hello-world/","title":"Program 2: Hello World","section":"Getting to Hello World","content":"From the exiting program, you can add a couple more lines before it to actually output the \u0026ldquo;Hello World!\u0026rdquo;\nLabels #  You have already used the _start: label but what does that actually do? A label simply names a place in the program that you can reference to later. In the data section, it\u0026rsquo;s common to label the beginning part of a piece of data. When this happens, that label and all references to it, will become the same address that points to a place in the data loaded into memory.\nThe data section #  In the data section, the format is:\nlabel:? .datatype data In this example you are going to use the ascii datatype which takes the data between the two double quotes and converts them to their ASCII equivalence. You will see other types of data in the near future.\nLDR operation #  Like the mov opcode, ldr loads a value into a register. However, unlike mov, ldr loads a value from memory. This is a small but very important difference. But in order to load a value from memory, you need to know where in memory it is located. Luckily for us, the compiler will do the calculation for use if you reference a label in the data section.\nldr r1, =hello @ Load the address that hello points to  @ into register 1  .data @ The next line labels the location our string starts as `hello` hello:.ascii \u0026#34;Hello World!\\n\u0026#34; "},{"id":20,"href":"/docs/registers-and-memory/find-the-otter/","title":"Program 3: Find the Otter","section":"Registers and Memory","content":"ADD operation #  You will focus on math heavy concepts later, but for now you do need one operator to increment for things like memory addresses and loops. Also, you may have guessed that the ADD opcode adds two numbers. Both of these formats are exactly the same.\nadd r0, r1, r2 @ Add r1 and r2 and store in r0  add r1, r2 @ Add r1 and r2 and store in r1 STR(-B) operation #  STR is the opposite of LDR. As such, STR takes a value in a register and inserts it into memory. Remember that registers are 32-bit values and that STR, by default, will write the complete 32-bit value to memory. In the next exercise we only should be moving a single byte as opposed to the full 4 bytes. We can do this; both with LDR and STR, by appending a -B suffix, we can work on single bytes at a time.1\nAccessing Values in Memory #  When you used a memory address in the \u0026ldquo;Hello World!\u0026rdquo; exercise, we took the address and provided it to the supervisor (the operating system) and it read the data in memory for us and wrote it to STDOUT. If YOU want to access the data at an address, you need to use the register but with brackets around the register number.2\nmov r0, #\u0026#39;A\u0026#39; @ load the value of A into r0  ldr r1, =outstr @ load address of outstr into r1  strb r0, [r1] @ store the first byte in r0 into the address  @ starting at r1  strb r0, r1 @ Does not work Reserving Space, Pt. 1 #  The last thing you need to know before going into this exercise is how to ask the computer to put a little space aside for the program to use. For now, use the data section and create a string full of spaces. You can even put the line ending there BEFORE writing the program as we already know the length of the output before you start.\n.data outstr:.ascii \u0026#34;\\n\u0026#34;   Worth noting, although not used throughout the overall course, that you can also use -H for moving a half word worth of data. (2 bytes)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n I think about it this way. Your friend gives you the address of their house. You find the address but you still need to go into the house. You can\u0026rsquo;t just go into the address. The brackets are what allow you to go to the house. Eccentric? Yes, but it helps me.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":21,"href":"/docs/branches-and-conditionals/hello-world-revisited/","title":"Program 5: Hello World Revisited","section":"Branches and Conditionals","content":"Including Other Files, Pt. 1 #  MACRO directive #  Putting everything in one file is great keeping code together, but absolutely awful for more than trivial programs as the number of lines of code grows rapidly. There are two ways you can include code in from other files and this is the first way. Like a keyboard macro, the MACRO directive puts an exact copy of the code at the point of inclusion.\n@ the syntax is .macro followed by the name of the macro followed by a @ comma seperated list of arguments expected. .macromacroname  arg1, arg2, arg3 @ arguments are inserted in the code with a backslash  mov r0, \\arg1 @ loads the immediate into r0  @ macros are ended by the .endm directive .endm Local labels #  Since the macro includes the code verbatim, you need to consider what would not work as if everything were in one file. One such instance would be labels as they need to be unique within the file. We can accomplish this by using local labels. Local labels are a number from 0-99 followed by a colon. You can then append either a -f or a -b to look for that number forward or backwards.\n1: add r0, #1 @ add 1 to r0  cmp r0, #5 @ compare 0 to 5  beq 2f @ go on if equal  b 1b 2: @ Code continues.... INCLUDE directive #  The last part of this is to actually include the file that has the macro if we put it in an external file. We do this with the include directive. The include directive simply includes the file, in the exact space, as if it were the same file.\nNull terminated strings #  When you use a macro, you start getting into an area where you need to trust the person using your code to provide things such as output memory space. So we need to create a macro that can be used in any program, even if we don\u0026rsquo;t know the length. One way programs do this is by null terminated data. It\u0026rsquo;s such a great idea, there\u0026rsquo;s a macro for that too! The two following data items will load the same data into memory.\n.data explictnull:.ascii \u0026#34;String with null\\0\u0026#34; datanull:.asciz \u0026#34;String with null\u0026#34; "},{"id":22,"href":"/docs/bit-operations/ok-be-negative/","title":"Program 12: Ok, Be Negative","section":"Bit Operations","content":"Using XOR for sign detection #  With signed integers, the most significant bit will always be 1 if the number is negative. Try XOR-ing two negative numbers in our imaginary 8-bit registers.\n0b11110110 -10 XOR 0b11011110 -35 ===================== 0b00101000 ^--- First bit 0 If you take a negative and a positive number, this happens.\n0b11110110 -10 XOR 0b00000010 2 ===================== 0b11110100 ^--- First bit 1 This is helpful because the N flag of the CPSR is a mirror of the most significant bit.\nTEQ operation #  As the CMP operation compares two numbers by subtraction and then sets the CPSR, there are a couple of other comparison operations that perform and operation and discard the result. Of of those is the TEQ operation which compares a EOR (XOR) on two operands and sets the CPSR based on the result.\n"},{"id":23,"href":"/docs/registers-and-memory/memory-copy/","title":"Program 4: Memory Copy","section":"Registers and Memory","content":"Reserving Space, Pt. 2 #  Sometimes (read most of the time) you probably won\u0026rsquo;t know the length of the output or exactly how much space you will need for the program. As opposed to writing a string in memory, you can use the fill directive to reserve space. The syntax is # of data parts to reserve, the size of the space to reserve, and the value to store in that space. If the default value is not provided, it will default to 0 (integer). If you provide the size of each data repeat, it must be 1, 2, or 4 referring number of bytes. If the size is omitted, it is assumed to be 1 (byte).1 There are other ways to reserve memory through the operating system, but they are outside the scope of this course.\nlabel:.fill 128 @ reserves 128 bytes label2:.fill 128, 2, 1 @ reserves 128 2-byte blocks (256 bytes)  @ with each 2-byte value equal to 1   It\u0026rsquo;s super important to note that with the ARM compiler, the syntax is slightly different. The order of the values is # of blocks, value, size. When in doubt, you can also just use .space in either syntax and provide the number of bytes followed by the fill value you want. (e.g., .space 128, 1 for 128 bytes set to the value 1)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":24,"href":"/docs/branches-and-conditionals/sticky-keyboard/","title":"Program 6: Sticky Keyboard","section":"Branches and Conditionals","content":"Are you tired of adding one all the time to increment memory addresses? What if I told you there was a better way? A way where you didn\u0026rsquo;t need the ADD opcode. A way that allows the processor to work in less cycles?!?!?!? Now for $19.95 I will show you the secret to be more efficient. Or you could just read below.\nIncrementing LDR/STR instructions #  Offset address #  The first method is to alter the address before the LDR or STR operation happens. When you use this syntax, the change in address does not write a new value to the address register. There are some use cases for this such as looking ahead in memory.\nldr r0, =address @ pretend the address loaded is 0x1000  ldrb r1, [r0, #2] @ this would load the byte at 0x1002 to r1  @ r0 still equals 0x1000 Pre-index address #  By using this method, the address with be adjusted before the LDR/STR operation (as above) however it will then write this address to the address register. The only difference is the addition of an ! after the offset.\nldr r0, =address @ pretend the address loaded is 0x1000  ldrb r1, [r0, #2]! @ this would load the byte at 0x1002 to r1  @ r0 would then be set to 0x1002 Post-index address #  This is the form that you will see most often. This will allow you to read an address and then offset the address value after the LDR/STR.\nldr r0, =address @ pretend the address loaded is 0x1000  ldrb r1, [r0], #2 @ this would load the byte at 0x1000 to r1  @ r0 is then set to 0x1002 "},{"id":25,"href":"/docs/arithmetic/itoa/","title":"Program 8: ITOA","section":"Arithmetic","content":"EQU directive #  While you don\u0026rsquo;t have variables in the standard sense, there is one naming thing you can do. You can use the EQU directive to define a read only number.\n.equ var1, 128 mov r0, #var1 "},{"id":26,"href":"/docs/branches-and-conditionals/inspecting-our-program/","title":"Inspecting Our Program","section":"Branches and Conditionals","content":"Inspecting Our Program #  There are at least two programs you can use to look at programs and debug. First, compile the following program using the command as -g -o main.o main.s. What the -g flag will do is add debug symbols to the executable. The linker command will be the same as before. (ld -o main main.o)\n.global_start  _start: mov r4, #2 @ load 2 into r4  add r4, #6 @ add 6 to r4  Object dump #  The first tool you can use is objdump. If you invoke it as objdump -d main you can see the actual commands that the assembler wrote to the file. For this simple program, the output is:\npi@raspberrypi:~/hrm$ objdump -d main main: file format elf32-littlearm Disassembly of section .text: 00010054 \u0026lt;_start\u0026gt;: 10054:\te3a04002 mov\tr4, #2 10058:\te2844006 add\tr4, r4, #6 The file format tells you that the file is an elf. If you recall, the part of the program where all of the instructions are is the .text section, so that makes sense. You can then see the _start label and our two operations, MOV and ADD.\nThis is helpful because sometimes the compiler will not use the same instructions that you think it is using. It will sometimes substitute some commands for others for various reasons.\nMachine code #  Welcome to the nitty-gritty. In the end, the processor (and computers in general) only understands 1\u0026rsquo;s and 0\u0026rsquo;s. In the above example, under the _start label in the first column, you can see the relative address each instruction appears at. This makes sense that the first instruction is at 0x10054 and the next at 0x10058 because each instruction is 32-bits or 4 bytes.\nThe next column is the actual machine code instruction but in hex format. If you write it in binary, it would look like this:\n11100011 10100000 01000000 00000010 The processor then takes these ones and zeros and understands it as this.\n  1 2 3 4 5 6 7 8   1110 00 1 1101 0 0000 0100 000000000010    Condition Code: 1110 = Always execute Always 00 for data processing 1 = Immediate operand at end as opposed to a register Opcode: 1101 = MOV Update CPSR: This would be 1 if we used an instruction with an -s suffix or a command such as CMP. Rn = 1st operand register: Since MOV only has a destination, this is 0 Rd = Destination register: 0010 = 4 Operand2 = This was explained in the very beginning. Because the flag in field 3 is set, this is an immediate value. 0b10 = 3  If you want to deep dive into decoding instructions, they are all explained in the manual.\nGNU Debugger #  The machine code is great for static analysis, but what if you want to inspect the program while it is running? The GNU Debugger (GDB) is a perfect tool to do this. There are a multitude of tutorials on how to use this tool as it has been in use for almost 35 years. Below is a quick overview but I would highly suggest reading the documentation or looking at a detailed cheatsheet\nRunning a program #  To start gdb, just invoke gdb application_name. After it loads, you will see a very uneventful gdb\u0026gt; prompt. To run the program and pause on the first operation, use start. If you would like to add any arguments, just add them after start. (e.g., start arg1 arg2) If you have set breakpoints, you can also use r or run to skip stopping on the first operation. The q command will exit GDB.\nSetting breakpoints #  If you want to stop on a label, you can simply type break labelname or b labelname. If you\u0026rsquo;re trying to set a breakpoint on a certain line, you can use the l command to show a list of the next 10 lines of the program. You can then set a breakpoint by typing b lineno. To remove a breakpoint, use d as opposed to b with the same argument you used to set the breakpoint.\nLeaving breakpoints #  After the program is stopped, you can:\n c: continue running until the next breakpoint s: Runs the next instruction (steps into function calls) n: Runs the next instruction (steps over function calls)  Reading data #  There are two primary ways to look at the values your program is using. The first is how you would examine memory.\nThe other way is to look at variable values, or in assembly the register values, using print.\n"},{"id":27,"href":"/docs/bit-operations/xor-cipher/","title":"Program 13: XOR Cipher","section":"Bit Operations","content":"Basic Cryptography #  Cryptography is an art that has always fascinated me. How do you take a message, encrypt it, and send it to someone else to read without allowing anyone else to read it. With the exclusive OR, you can do basic encryption that is similar to a ROT13 or the little coder wheels that used to be in cereal boxes.1\nThe way that this works is you first take a message you want to encrypt. For this instance, try using: \u0026ldquo;ABC\u0026rdquo;. If you take this and convert it into the numerical representation, it turns into:\nA B C 01000001 01000010 01000011 From here you need to find a secret number. Depending on how complex you want to make this, it can be any size. If the key is shorter than the message, you just repeat the key over and over. For this, use the magic number -2. (0b11111110) Perform the XOR:\nA B C 01000001 01000010 01000011 XOR 11111110 11111110 11111110 =============================== 10111111 10111100 10111101 The magic happens when you XOR the result with the same key.\n10111111 10111100 10111101 XOR 11111110 11111110 11111110 =============================== 01000001 01000010 01000011   I don\u0026rsquo;t personally remember these. But from everyone older than me, they all talk about them. So it\u0026rsquo;s either a conspiracy involving almost everyone I know or true.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":28,"href":"/docs/arithmetic/the-stack/","title":"The Stack","section":"Arithmetic","content":"The Stack #  We spoke before about the different places that data can live, now we will dive into how those places are used. Hard Drives/SSDs are use to store data \u0026ldquo;long term.\u0026rdquo; And by long term I mean generally longer than the invocation of a program. It\u0026rsquo;s also used for files that are exceptionally large.\nWithin the RAM, there are two primary areas: the stack and the heap. These concepts are constructs of the operating system. The processor doesn\u0026rsquo;t understand stack and heap in the same way the processor doesn\u0026rsquo;t understand negative numbers. Because of this, it is up to the programmer in lower level languages to understand how to use these tools.1\nHow Linux uses the stack #  When a program is started, it is allocated a space in memory (RAM) where it can store data that it is working with. This memory follows a Last-In-First-Out model. The amount of memory that is allocated to the running program is determined by the operating system. The other oddity is that the stack \u0026ldquo;grows\u0026rdquo; down.\nHere is an example:\n   Address Order Added     0x0100 1st   0x00FC 2nd   0x00F8 3rd   0x00F4 4th    Stack Pointer #  There was a small warning when talking about the registers that said \u0026ldquo;don\u0026rsquo;t touch r13!\u0026rdquo; r13 is what is called the stack pointer. This is simply an address to a place in RAM where the last value was put in the stack. When we put data into the stack, or remove data, we need to make sure this pointer is moving to the correct place in order to avoid memory leaks. Some commands, like push and pop below, do this for us automatically. Other situations, like managing stack frames, may require a little more interaction.\nPUSH and POP operations #  To get information on and off the stack, we can push and pop the values. When we use the push and pop commands, we are really just calling the store multiple (STM) and load multiple (LDM) instructions with a little syntax sugar.2 You can either push/pop a single register or multiple ones.\npush {r0-r3} @ pushes (saves) r0-r3 onto the stack  @ above can also be written  @ push {r0, r1, r2, r3}  add r1, #2 @ adds 2 to r1  pop {r0-r3} @ pops (loads) r0-r3 from the stack  @ this would negate the add function  @ and restore r0-r3 to their previous  @ values from the stack   Heap management is getting way more into the nitty gritty that this assembly course plans to get into. This is highly studied and is very case dependant on which is best to use for certain situations. \u0026ldquo;Light\u0026rdquo; reading for those interested.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n More specifically STMDB and LDMIA or decrement address before store and increment address after load, where address refers to the stack pointer. We\u0026rsquo;ll get there in a second.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":29,"href":"/docs/branches-and-conditionals/cloning-myself/","title":"Program 7: Cloning Myself","section":"Branches and Conditionals","content":"Make files #  In the current day of project builders, scaffolding, runners, and so forth one may forget that there was a time, not so long ago, that you could just use a program installed on almost every *nix operating system. That program is make.\nThe syntax for a make file is very simple.\ntarget: prerequisites \u0026lt;TAB\u0026gt;steps to build The first part is defining which files you need for the program. For the basic single file that you have been using, you only need one fine: main.o. Then you need to tell make how to create the main.o file.\nmain: main.o ld -o main main.o main.o: main.s as -o main.o main.s Soon, however, you will be writing programs with more than one object file. In order to create a base make file that can easily be edited, you need to adapt it slightly.\n# Define the object files you need for the final executable OBJS = main.o # The next line uses % which is a wildcard character to refer to all .s and .o files %.o : %.s # $\u0026lt; = source file, $@ = output file  as $\u0026lt; -o $@ # build the main executable main: $(OBJS) ld -o main $(OBJS) "},{"id":30,"href":"/docs/arithmetic/factorial/","title":"Program 9: Factorials","section":"Arithmetic","content":" .stack-grid { display: grid; grid-template-columns: [fn] 1fr [frame] 1fr [label] 1fr [end]; border: 2px solid black; } .stack-fn { padding-left: 4px; grid-column: fn / frame; } .frame { grid-column: frame / label; height: 32px; border-width: 0px 2px 2px 2px; border-color: black; border-style: solid; padding-left: 4px; line-height: 32px; } .stack-label { grid-column: label / end; padding-lect: 4px; } .frame:last-of-type { border-bottom-width: 0px; }  Including Other Files, Pt. 2 #  In addition to using macros, we can use instructions in compile object files. In this template, you can see the itoa.s file has been moved here with all of the code. When we assemble the source into an object file, we are making a primitive static library.\nTo expose code, you need to tell the linker what functions it can use. This is similar to exporting or marking code as public in other languages. In ARM assembly, you just specify .global label. This is why we need to put the .global _start in our main file \u0026ndash; so the linker cna find it. To include the code, it\u0026rsquo;s as simple as giving both files to the linker. The makefile will do this for you automatically for this program.\n$ ld -o main main.o itoa.o Stack Frame #  One very common way of managing the stack is by using \u0026ldquo;frames\u0026rdquo; to outline data \u0026ldquo;packages\u0026rdquo; on the stack. Although this is a somewhat more theoretical discussion of how to use the stack, we will use it for our next program. The idea is that every procedure or function will have it\u0026rsquo;s own little space in the stack where it can keep its information in an ordered way. If we had the following code: (non-sensical)\nfn main() { let res = a(1, 2); } fn a(param1: i32, param2: i32) -\u0026gt; i32 { b(param2) + 3 } fn b(param1: i32) -\u0026gt; i32 { param1 + 1 } This is what the stack may possibly look like right before the point of adding 1 to param1 in b().\nOS ENV params ...  â¬…ï¸ Base pointer addr for main() main() Space for local param `res` Param 2 for a() Param 1 for a() Return to main() address Address for main() base pointer â¬…ï¸ Base pointer addr for a() a() Saved registers Local var if needed Param 1 for b() Return to a() address Address for a() base pointer â¬…ï¸ Base pointer addr for b() b() Saved registers Local var if needed â¬…ï¸ Stack pointer  Generally the caller function will push the params to the callee in reverse order. After that, the branch is made. When the callee recieves control, the callee will save both the return address as well as the old frame base address. It will then move the frame base to the same value as the stack pointer and we have our new frame.\nFrame Base Pointer #  Why do we use a frame base? It seems like information that we can just get rid of, right? We already have a stack pointer. A frame pointer allows us to refer to values without regard of tracking exactly where the stack pointer is located. If you look at the above chart again, notice that the old base pointer address is always in the same place in relation the the current base pointer. The return address is always in the same place in relation the current base pointer. The parameters for the called functions are always in the same place in relation to the base pointer.\nBL and BX operations #  One of those other registers that I said never to touch is the link register or r14. When using the branch-and-link (BL) opcode, the next instruction address is stored in r14 and branches to the address the opcode specifies. At the end of the routine you then use the branch-and-exchange opcode (BX) to go back to where you left off.\nExample using BL and BX #  add.s #  .globaladd  add: add r0, #2 @ add 2 to register 0  bx lr @ branch and exchange to where you jumped from main.s #  .global_start  _start: mov r0, #3 @ move 3 into r0  bl add @ jump to add  @ here r0 = 5 (3 + 2)  @ ... code continues Recursive functions #  If you combine these two ideas, you can start writing recursive functions! In addition to pushing the values you want to save, push lr (link register) after the bl as well. When the string of recursive calls terminates, because you are pushing lr, you would be able to pop {lr} before bx lr and get back to wherever you started. If you didn\u0026rsquo;t push the return address, you would get into a loop as the bl overwrites the link register every time.\n"},{"id":31,"href":"/docs/bit-operations/shifting/","title":"Shifting and Rotating","section":"Bit Operations","content":"Shifting and Rotating #  Shifting and rotating refer to the process of taking the bits of a number and moving them either to the left or the right. The ARM processor has a barrel shifter included in the hardware which allows you to shift the flexible operand2.\nRotating #  Rotating is the operation where when bits get to the end of the register, they move to the other side. There are two rotate instructions.\nROR operation #  mov r0, #0b11001100 @ r0 = 00000000 00000000 00000000 11111111  ror r0, r0, #2 @ shift to the right 2  @ r0 = 11000000 00000000 00000000 00111111 RRX operation #  The RRX operation functions exactly like ROR, but instead of a 32-bit register, it treats the carry flag in the CPSR as a 33rd bit. It, however, can only move one bit at a time.\nmov r0, #0b11001100 @ r0 = 00000000 00000000 00000000 11111111 C = 0  rrx r0, r0 @ shift to the right 1  @ r0 = 00000000 00000000 00000000 01111111 C = 1  @ if carry were 1 during move operation, it would  @ have ended up in bit 31  Shifts #  Logical shifts #  The logical shift right (LSR) and logical shift left (LSL) shift bits and move the last removed flag to the carry bit of the CPSR if the s suffix is added.\nmov r0, #0xff00ff00 @ r0 = 11111111 00000000 11111111 00000000 C=0  lsls r0, r0, #10 @ r0 = 00000011 11111100 00000000 00000000 C=0  mov r1, #0xff00ff00 @ r0 = 11111111 00000000 11111111 00000000 C=0  lsrs r1, r1, #10 @ r0 = 00000000 00111111 11000000 00111111 C=1 Arithmetic shift #  You may see the problem with shifting \u0026ndash; it always moves zeros into the register. If you are still thinking about negative numbers, you can see why this would be an issue. If you add a zero to the front of a \u0026ldquo;negative\u0026rdquo; number, then it\u0026rsquo;s not \u0026ldquo;negative\u0026rdquo; anymore. Because of this, there is also a arithmetic shift right (ASR) which will preserve the sign by copying the 31st bit and not just zero.\nmov r0, #-23 @ r0 = 11111111 11111111 11111111 11101001 C=0  asr r0, r0, #4 @ r0 = 11111111 11111111 11111111 11111110 C=1 "},{"id":32,"href":"/docs/arithmetic/sum-of-squares/","title":"Program 10: Sum of Squares","section":"Arithmetic","content":" "},{"id":33,"href":"/docs/bit-operations/hex-and-love/","title":"Program 14: Hex and Love","section":"Bit Operations","content":"Converting decimal to hexadecimal #  You know that you can enter numbers as decimal, octal, binary, or hexadecimal. The question is, however, how do you actually change base? Going from binary (base 2) to hexadecimal (base 16) is fairly easy because 2 fits inside of 16. When you go from decimal (base 10) to hexadecimal, you need to get to that intermediate step.\nTake the number 200. To visualize the base change better, write 200 in binary. From there you can see that 200 fits inside 1 byte. Within that byte, you can break it into two 4-bit slices. These two 4-bit slices are then converted to 0-F to get the hexadecimal representation.\nDecimal: 200 Binary: 11001000 Group1: 1100 = 12 =\u0026gt; c Group2: 1000 = 8 =\u0026gt; 8 Hexadecimal: c8 "},{"id":34,"href":"/docs/bit-operations/unsale/","title":"Program 15: The Un-sale","section":"Bit Operations","content":"Multiply by \u0026lt;base\u0026gt; #  In decimal, it\u0026rsquo;s really easy to multiply by 10. You just simply add a 0 to the end of the number.\n3 * 10 = 30 30 * 10 = 300 Boom. Did you know this works in every base?\n0x1 (1) * 16 = 0x10 (16) 0x10 (16) * 16 = 0x100 (256) Boom. You can take this knowledge and combine it with left shifts to multiply by 2 easily.\n2 (0b10) * 2 = 0b100 (4) 4 (0b100) * 2 = 0b1000 (8) 8 (0b1000) * 2 = 0b10000 (16) 16 (0b10000) * 2 = 0b100000 (32) And right shifts? Divide by two!\nRSB operation #  Generally the SUB operation is great. You have a number and you want to subtract another number, works perfect. Sometimes though, it may be beneficial to put the \u0026ldquo;larger\u0026rdquo; number in the operand2. This would allow you to do things like shifting a value and then subtracting from that. The ARM processor has such an operation call RSB or reverse subtraction.\nrsb r0, r1, r2 @ subtract r1 from r2 and store in r0  @ r2 can be any form of the operand2 Note on pre-optimization #  One trap I think many programmers fall into (myself included) is to optimize a program before there is a problem. Sometimes it\u0026rsquo;s only by doing the \u0026ldquo;wrong and slow\u0026rdquo; way that you realize that it\u0026rsquo;s actually okay. There are also some times where the compiler will use intermediate steps (e.g., LLVM) and optimize it better than you could. However, for this problem, I\u0026rsquo;m asking you to pre-optimize on purpose.\nIt would be very easy to write this:\nmov r1, #3 @ this only needs to be done once to mul by reg  mov r0, #5 @ this would be once per loop  mul r0, r0, r1 @ mul r0 * r1 (3) and store in r0 MUL will take a maximum of 5 processor cycles depending on number size. While writing small programs this isn\u0026rsquo;t a problem. If you\u0026rsquo;re writing a program that will process billions or trillions of operations, it can add up. (Think possibly a transform on a video stream) The ARM processor that is inside the Raspberry Pi I use for writing these programs has a 900MHz processor. That is only 180,000,000 multiplications a second at its slowest. This is where getting creative can pay off.\nThere is a way that only takes 1 cycle1.\nIf you wrote this:\nmov r1, #3 @ this is once per loop again  rsb r0, r1, r1 lsl #2 @ essentially 4(r1) - r1 The reverse subtract, even with the shift, would only take one cycle. This is because the barrel shifter is outside of the ALU and will do some of the heavy lifting here. There are some limitations as this wouldn\u0026rsquo;t work with float numbers (you shouldn\u0026rsquo;t be using float numbers for currency anyway ðŸ¤·â€â™‚ï¸), the numbers you use would need to fit inside the first 30 bits so the shift didn\u0026rsquo;t lose data, etc. Doing this, though, would only take (at best) 1/5th of the time and 1/2 the time at worst\n  99% sure from the spec. Please correct me if it\u0026rsquo;s not\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"id":35,"href":"/docs/bit-operations/64-bit-math/","title":"Program 16: 64-bit Math","section":"Bit Operations","content":"Binary long division #  If you remember back in middle school (elementary?), long division was one of those things where you probably just though, \u0026ldquo;can\u0026rsquo;t I use a calculator?\u0026rdquo; Can you do this with other bases other than 10? Absolutely. Welcome to long division, binary edition.\nIt\u0026rsquo;s actually pretty simple. Look at an example of 200/8.\n00011001 = 25 __________ 1000 | 11001000 1: 1 2: 11 3: 110 4: 1100 -1000 0100 5: 1001 -1000 0001 6: 10 7: 100 8: 1000 -1000 As opposed to re-inventing the wheel, Ben Eater has a great detailed video explaining how to do this with a computer. Video\n"}]